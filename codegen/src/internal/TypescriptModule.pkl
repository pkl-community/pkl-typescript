import "pkl:reflect"
import "TypescriptMapping.pkl"
import "Gen.pkl"
import "ClassGen.pkl"
import "utils.pkl"

`module`: reflect.Module

/// All mappings
mappings: List<TypescriptMapping>

typescriptModule: String?

local moduleMappings: List<TypescriptMapping> =
  mappings.filter((it) -> it.typescriptModule == typescriptModule)

local moduleClass = moduleMappings[0]

local function describeLocation(src: reflect.TypeDeclaration) =
  let (memberType =
    if (src is reflect.Class && src.enclosingDeclaration.moduleClass == src) "module"
    else if (src is reflect.Class) "class"
    else "typealias"
  )
    "* \(memberType) `\(src.reflectee)` (\(src.location.displayUri))"


local function hasUniqueNames(): Boolean =
  let (names = moduleMappings.map((it) -> it.name))
    if (names.isDistinct) true
    else
      let (duplicateNames = moduleMappings.filter((it) -> moduleMappings.count((m) -> m.name == it.name) > 1))
      let (locations = duplicateNames.map((it) -> describeLocation(it.source)).join("\n"))
        throw("""
          Conflict: multiple Pkl declarations compute to TypeScript name `\(duplicateNames.first.name)`.

          To resolve this conflict, add a `@typescript.Name` annotation to any of the following declarations:

          \(locations)

          For example:

          ```
          @typescript.Name { value = "CrabCakes" }
          class Crab_Cakes
          ```
          """)

local generated: List<Gen>(hasUniqueNames()) =
  moduleMappings.map((it) ->
  // if (it is TypescriptMapping.Class)
    new ClassGen {
      mappings = module.mappings
      mapping = it
    })
  // }
  // If not a class, what then?

contents: String = new Listing {
  """
  // This file was generated by `pkl-typescript` from Pkl module `\(`module`.moduleClass.enclosingDeclaration.name)`.
  // DO NOT EDIT.
  """

  for (gen in generated) {
    gen.contents
    ""
  }

  when (!`module`.modifiers.contains("open") && !`module`.modifiers.contains("abstract")) {
    """
    // LoadFromPath loads the pkl module at the given path and evaluates it into a \(moduleClass.name)
    export const loadFromPath = async (path: string): Promise<\(moduleClass.type.render(moduleClass.typescriptModule))> => {
      const evaluator = await pklTypescript.newEvaluator(pklTypescript.PreconfiguredOptions);
      try {
        const result = await load(evaluator, pklTypescript.FileSource(path));
        return result
      } finally {
        evaluator.close()
      }
    };

    export const load = (evaluator: pklTypescript.Evaluator, source: pklTypescript.ModuleSource): Promise<\(moduleClass.type.render(moduleClass.typescriptModule))> =>
      evaluator.evaluateModule(source) as Promise<\(moduleClass.type.render(moduleClass.typescriptModule))>;

    """
  }
}.join("\n")


output {
  files {
    // Snake-case the generated filenames, as per the Google TypeScript styleguide:
    // https://google.github.io/styleguide/tsguide.html#identifiers-imports
    // > "Module namespace imports are lowerCamelCase while files are snake_case"
    ["\(utils.snakeCase(`module`.name)).pkl.ts"] {
      text = contents
    }
  }
}
